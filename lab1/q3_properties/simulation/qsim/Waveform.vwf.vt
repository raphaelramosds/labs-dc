// Copyright (C) 1991-2013 Altera Corporation
// Your use of Altera Corporation's design tools, logic functions 
// and other software and tools, and its AMPP partner logic 
// functions, and any output files from any of the foregoing 
// (including device programming or simulation files), and any 
// associated documentation or information are expressly subject 
// to the terms and conditions of the Altera Program License 
// Subscription Agreement, Altera MegaCore Function License 
// Agreement, or other applicable license agreement, including, 
// without limitation, that your use is for the sole purpose of 
// programming logic devices manufactured by Altera and sold by 
// Altera or its authorized distributors.  Please refer to the 
// applicable agreement for further details.

// *****************************************************************************
// This file contains a Verilog test bench with test vectors .The test vectors  
// are exported from a vector file in the Quartus Waveform Editor and apply to  
// the top level entity of the current Quartus project .The user can use this   
// testbench to simulate his design using a third-party simulation tool .       
// *****************************************************************************
// Generated on "09/04/2022 16:50:31"
                                                                        
// Verilog Self-Checking Test Bench (with test vectors) for design :    properties
// 
// Simulation tool : 3rd Party
// 

`timescale 1 ps/ 1 ps
module properties_vlg_sample_tst(
	a,
	b,
	c,
	sampler_tx
);
input  a;
input  b;
input  c;
output sampler_tx;

reg sample;
time current_time;
always @(a or b or c)
                                                                                
begin                                                 
 if ($realtime > 0)                                   
 begin                                                
	if ($realtime == 0 || $realtime != current_time)  
	begin									          
		if (sample === 1'bx)                          
			sample = 0;                               
		else                                          
			sample = ~sample;                         
	end										          
	current_time = $realtime;					      
 end                                                  
end                                                   

assign sampler_tx = sample;
endmodule

module properties_vlg_check_tst (
	a11,
	a12,
	a21,
	a22,
	c11,
	c12,
	c21,
	c22,
	d11,
	d12,
	d21,
	d22,
	i01,
	i02,
	i03,
	m11,
	m12,
	m21,
	m22,
	sampler_rx
);
input  a11;
input  a12;
input  a21;
input  a22;
input  c11;
input  c12;
input  c21;
input  c22;
input  d11;
input  d12;
input  d21;
input  d22;
input  i01;
input  i02;
input  i03;
input  m11;
input  m12;
input  m21;
input  m22;
input sampler_rx;

reg  a11_expected;
reg  a12_expected;
reg  a21_expected;
reg  a22_expected;
reg  c11_expected;
reg  c12_expected;
reg  c21_expected;
reg  c22_expected;
reg  d11_expected;
reg  d12_expected;
reg  d21_expected;
reg  d22_expected;
reg  i01_expected;
reg  i02_expected;
reg  i03_expected;
reg  m11_expected;
reg  m12_expected;
reg  m21_expected;
reg  m22_expected;

reg  a11_prev;
reg  a12_prev;
reg  a21_prev;
reg  a22_prev;
reg  c11_prev;
reg  c12_prev;
reg  c21_prev;
reg  c22_prev;
reg  d11_prev;
reg  d12_prev;
reg  d21_prev;
reg  d22_prev;
reg  i01_prev;
reg  i02_prev;
reg  i03_prev;
reg  m11_prev;
reg  m12_prev;
reg  m21_prev;
reg  m22_prev;

reg  m11_expected_prev;
reg  m12_expected_prev;
reg  m21_expected_prev;
reg  m22_expected_prev;

reg  last_m11_exp;
reg  last_m12_exp;
reg  last_m21_exp;
reg  last_m22_exp;

reg trigger;

integer i;
integer nummismatches;

reg [1:19] on_first_change ;


initial
begin
trigger = 0;
i = 0;
nummismatches = 0;
on_first_change = 19'b1;
end

// update real /o prevs

always @(trigger)
begin
	a11_prev = a11;
	a12_prev = a12;
	a21_prev = a21;
	a22_prev = a22;
	c11_prev = c11;
	c12_prev = c12;
	c21_prev = c21;
	c22_prev = c22;
	d11_prev = d11;
	d12_prev = d12;
	d21_prev = d21;
	d22_prev = d22;
	i01_prev = i01;
	i02_prev = i02;
	i03_prev = i03;
	m11_prev = m11;
	m12_prev = m12;
	m21_prev = m21;
	m22_prev = m22;
end

// update expected /o prevs

always @(trigger)
begin
	m11_expected_prev = m11_expected;
	m12_expected_prev = m12_expected;
	m21_expected_prev = m21_expected;
	m22_expected_prev = m22_expected;
end



// expected m11
initial
begin
	m11_expected = 1'bX;
end 

// expected m12
initial
begin
	m12_expected = 1'bX;
end 

// expected m21
initial
begin
	m21_expected = 1'bX;
end 

// expected m22
initial
begin
	m22_expected = 1'bX;
end 
// generate trigger
always @(a11_expected or a11 or a12_expected or a12 or a21_expected or a21 or a22_expected or a22 or c11_expected or c11 or c12_expected or c12 or c21_expected or c21 or c22_expected or c22 or d11_expected or d11 or d12_expected or d12 or d21_expected or d21 or d22_expected or d22 or i01_expected or i01 or i02_expected or i02 or i03_expected or i03 or m11_expected or m11 or m12_expected or m12 or m21_expected or m21 or m22_expected or m22)
begin
	trigger <= ~trigger;
end

always @(posedge sampler_rx or negedge sampler_rx)
begin
`ifdef debug_tbench
	$display("Scanning pattern %d @time = %t",i,$realtime );
	i = i + 1;
	$display("| expected a11 = %b | expected a12 = %b | expected a21 = %b | expected a22 = %b | expected c11 = %b | expected c12 = %b | expected c21 = %b | expected c22 = %b | expected d11 = %b | expected d12 = %b | expected d21 = %b | expected d22 = %b | expected i01 = %b | expected i02 = %b | expected i03 = %b | expected m11 = %b | expected m12 = %b | expected m21 = %b | expected m22 = %b | ",a11_expected_prev,a12_expected_prev,a21_expected_prev,a22_expected_prev,c11_expected_prev,c12_expected_prev,c21_expected_prev,c22_expected_prev,d11_expected_prev,d12_expected_prev,d21_expected_prev,d22_expected_prev,i01_expected_prev,i02_expected_prev,i03_expected_prev,m11_expected_prev,m12_expected_prev,m21_expected_prev,m22_expected_prev);
	$display("| real a11 = %b | real a12 = %b | real a21 = %b | real a22 = %b | real c11 = %b | real c12 = %b | real c21 = %b | real c22 = %b | real d11 = %b | real d12 = %b | real d21 = %b | real d22 = %b | real i01 = %b | real i02 = %b | real i03 = %b | real m11 = %b | real m12 = %b | real m21 = %b | real m22 = %b | ",a11_prev,a12_prev,a21_prev,a22_prev,c11_prev,c12_prev,c21_prev,c22_prev,d11_prev,d12_prev,d21_prev,d22_prev,i01_prev,i02_prev,i03_prev,m11_prev,m12_prev,m21_prev,m22_prev);
`endif
	if (
		( m11_expected_prev !== 1'bx ) && ( m11_prev !== m11_expected_prev )
		&& ((m11_expected_prev !== last_m11_exp) ||
			on_first_change[16])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port m11 :: @time = %t",  $realtime);
		$display ("     Expected value = %b", m11_expected_prev);
		$display ("     Real value = %b", m11_prev);
		nummismatches = nummismatches + 1;
		on_first_change[16] = 1'b0;
		last_m11_exp = m11_expected_prev;
	end
	if (
		( m12_expected_prev !== 1'bx ) && ( m12_prev !== m12_expected_prev )
		&& ((m12_expected_prev !== last_m12_exp) ||
			on_first_change[17])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port m12 :: @time = %t",  $realtime);
		$display ("     Expected value = %b", m12_expected_prev);
		$display ("     Real value = %b", m12_prev);
		nummismatches = nummismatches + 1;
		on_first_change[17] = 1'b0;
		last_m12_exp = m12_expected_prev;
	end
	if (
		( m21_expected_prev !== 1'bx ) && ( m21_prev !== m21_expected_prev )
		&& ((m21_expected_prev !== last_m21_exp) ||
			on_first_change[18])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port m21 :: @time = %t",  $realtime);
		$display ("     Expected value = %b", m21_expected_prev);
		$display ("     Real value = %b", m21_prev);
		nummismatches = nummismatches + 1;
		on_first_change[18] = 1'b0;
		last_m21_exp = m21_expected_prev;
	end
	if (
		( m22_expected_prev !== 1'bx ) && ( m22_prev !== m22_expected_prev )
		&& ((m22_expected_prev !== last_m22_exp) ||
			on_first_change[19])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port m22 :: @time = %t",  $realtime);
		$display ("     Expected value = %b", m22_expected_prev);
		$display ("     Real value = %b", m22_prev);
		nummismatches = nummismatches + 1;
		on_first_change[19] = 1'b0;
		last_m22_exp = m22_expected_prev;
	end

	trigger <= ~trigger;
end
initial 

begin 
$timeformat(-12,3," ps",6);
#1000000;
if (nummismatches > 0)
	$display ("%d mismatched vectors : Simulation failed !",nummismatches);
else
	$display ("Simulation passed !");
$finish;
end 
endmodule

module properties_vlg_vec_tst();
// constants                                           
// general purpose registers
reg a;
reg b;
reg c;
// wires                                               
wire a11;
wire a12;
wire a21;
wire a22;
wire c11;
wire c12;
wire c21;
wire c22;
wire d11;
wire d12;
wire d21;
wire d22;
wire i01;
wire i02;
wire i03;
wire m11;
wire m12;
wire m21;
wire m22;

wire sampler;                             

// assign statements (if any)                          
properties i1 (
// port map - connection between master ports and signals/registers   
	.a(a),
	.a11(a11),
	.a12(a12),
	.a21(a21),
	.a22(a22),
	.b(b),
	.c(c),
	.c11(c11),
	.c12(c12),
	.c21(c21),
	.c22(c22),
	.d11(d11),
	.d12(d12),
	.d21(d21),
	.d22(d22),
	.i01(i01),
	.i02(i02),
	.i03(i03),
	.m11(m11),
	.m12(m12),
	.m21(m21),
	.m22(m22)
);

// a
always
begin
	a = 1'b0;
	a = #10000 1'b1;
	#10000;
end 

// b
always
begin
	b = 1'b0;
	b = #20000 1'b1;
	#20000;
end 

// c
initial
begin
	repeat(12)
	begin
		c = 1'b0;
		c = #40000 1'b1;
		# 40000;
	end
	c = 1'b0;
end 

properties_vlg_sample_tst tb_sample (
	.a(a),
	.b(b),
	.c(c),
	.sampler_tx(sampler)
);

properties_vlg_check_tst tb_out(
	.a11(a11),
	.a12(a12),
	.a21(a21),
	.a22(a22),
	.c11(c11),
	.c12(c12),
	.c21(c21),
	.c22(c22),
	.d11(d11),
	.d12(d12),
	.d21(d21),
	.d22(d22),
	.i01(i01),
	.i02(i02),
	.i03(i03),
	.m11(m11),
	.m12(m12),
	.m21(m21),
	.m22(m22),
	.sampler_rx(sampler)
);
endmodule

